"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[3307],{8344:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var i=n(4848),o=n(8453);const a={},s="Window",r={id:"resources/views/window",title:"Window",description:"Working with frames in the World of Warcraft API usually envolves a lot of",source:"@site/docs/resources/views/window.md",sourceDirName:"resources/views",slug:"/resources/views/window",permalink:"/docs/resources/views/window",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/resources/views/window.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"View Constants",permalink:"/docs/resources/views/view-constants"},next:{title:"Testing",permalink:"/docs/category/testing"}},d={},l=[{value:"How to create and show a window",id:"how-to-create-and-show-a-window",level:2},{value:"Showing and hiding the window",id:"showing-and-hiding-the-window",level:2},{value:"Adding content to the window",id:"adding-content-to-the-window",level:2},{value:"Window persistent state",id:"window-persistent-state",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"window",children:"Window"})}),"\n",(0,i.jsx)(t.p,{children:"Working with frames in the World of Warcraft API usually envolves a lot of\r\ncode to create, position, manage, add scrollbars, persist state between\r\ninterface reloads, and so on."}),"\n",(0,i.jsx)(t.p,{children:"Although the game frames are flexible and powerful, they can be a bit\r\noverwhelming for developers who just want to create a simple window to show\r\nsome information and simple controls for players."}),"\n",(0,i.jsxs)(t.p,{children:["When a simple window with basic features is needed, the ",(0,i.jsx)(t.code,{children:"Window"})," class can be\r\nused or extended to create a new window and add it to the game interface."]}),"\n",(0,i.jsx)(t.p,{children:"The Stormwind Library provides a simple way to create windows with basic\r\nfeatures, like:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Showing a title"}),"\n",(0,i.jsx)(t.li,{children:"Showing a close button"}),"\n",(0,i.jsx)(t.li,{children:"Resizing and moving the window"}),"\n",(0,i.jsx)(t.li,{children:"Limiting the window size"}),"\n",(0,i.jsx)(t.li,{children:"Adding a scrollbar to the main window content"}),"\n",(0,i.jsx)(t.li,{children:"Persisting the window position and size between interface reloads"}),"\n",(0,i.jsx)(t.li,{children:"An easy way to attach frames to the window with a vertical layout"}),"\n",(0,i.jsx)(t.li,{children:"Add controls grouped by pages to easily switch between them, so the window\r\ncan be reused for different addon features"}),"\n",(0,i.jsx)(t.li,{children:"More to come..."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"how-to-create-and-show-a-window",children:"How to create and show a window"}),"\n",(0,i.jsxs)(t.p,{children:["Although ",(0,i.jsx)(t.code,{children:"Window"})," can be extended to create more complex windows, this article\r\nwill focus on how to instantiate and show a simple window."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",children:"local window = library\r\n    :new('Window', 'my-window-id')\r\n    :create()\n"})}),"\n",(0,i.jsx)(t.p,{children:"And that's it! The code above will create a blank window at the center of the\r\nscreen with a default size that's probably smaller than you want, but it will\r\nbe enough to get you started."}),"\n",(0,i.jsx)(t.p,{children:"Now, let's see how to create the same window with a bit more customization:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",children:"local window = library\r\n    :new('Window', 'my-window-id')\r\n    :setTitle('My Window')\r\n    :setFirstPosition({point = 'CENTER', relativePoint = 'CENTER', xOfs = 0, yOfs = 0})\r\n    :setFirstSize({width = 250, height = 400})\r\n    :setFirstVisibility(true)\r\n    :create()\n"})}),"\n",(0,i.jsx)(t.p,{children:"Although the code above uses some default values, it shows how to set the\r\nwindow title, position, size, and initial visibility."}),"\n",(0,i.jsx)(t.h2,{id:"showing-and-hiding-the-window",children:"Showing and hiding the window"}),"\n",(0,i.jsxs)(t.p,{children:["In the World of Warcraft API, frames have the ",(0,i.jsx)(t.code,{children:"Show()"})," and ",(0,i.jsx)(t.code,{children:"Hide()"})," methods to\r\ncontrol the frame visibility. Although the ",(0,i.jsx)(t.code,{children:"Window"})," class has the same\r\nmethods, they're used internally as the class exposes the ",(0,i.jsx)(t.code,{children:"setVisibility()"}),"\r\nmethod that accepts a boolean value to show or hide the window."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsxs)(t.strong,{children:["Addons should always use the ",(0,i.jsx)(t.code,{children:"setVisibility()"})," or ",(0,i.jsx)(t.code,{children:"toggleVisibility()"})," methods"]}),"\r\nto show or hide the window as they persist the window visible state between\r\ninterface reloads. In other words, if users close the window, the library will save\r\nthis state and when the game interface is reloaded, the window will be hidden."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",children:"-- consider a window instance created by\r\nlocal window = library:new('Window', 'my-window-id')\r\n\r\n-- hides the window\r\nwindow:setVisibility(false)\r\n\r\n-- shows the window\r\nwindow:setVisibility(true)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"toggleVisibility()"})," method was introduced in Stormwind Library version 1.12.0\r\nto show the window if it's hidden and hide it if it's shown."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",children:"-- consider a window which is visible\r\nwindow:setVisibility(true)\r\n\r\n-- toggles the window visibility, hiding it\r\nwindow:toggleVisibility()\r\n\r\n-- if called again, it will show the window\r\nwindow:toggleVisibility()\n"})}),"\n",(0,i.jsx)(t.h2,{id:"adding-content-to-the-window",children:"Adding content to the window"}),"\n",(0,i.jsx)(t.p,{children:"One of the motivations to create the Window class was to provide an easy way\r\nto add content that was also wrapped by a vertical scroll bar in case it's\r\nbig enough to overflow the window."}),"\n",(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsxs)(t.mdxAdmonitionTitle,{children:["The old ",(0,i.jsx)(t.code,{children:"Window:setContent()"})," method"]}),(0,i.jsx)(t.p,{children:"Just a little bit of history to add context to the current implementation."}),(0,i.jsxs)(t.p,{children:["The first Window version used to provide a method called ",(0,i.jsx)(t.code,{children:"setContent()"}),",\r\naccepting a list of frames that would be automatically positioned in the\r\nwindow content area like blocks."]}),(0,i.jsx)(t.p,{children:"However, that approach introduced some limitations, especially when addons\r\nneeded to add frames that would replace the whole content area. Given the\r\nway blocks are vertically stacked, it was hard to manage the inner frames\r\nand hide or show the right ones according to the addon needs."}),(0,i.jsx)(t.p,{children:"As an example, if the addon wanted to have a settings section and the main\r\nsection showing whatever information it needed, it would have to hide them\r\nand move the section relative points programmatically, which was a bit\r\ncumbersome."})]}),"\n",(0,i.jsxs)(t.p,{children:["Version 1.9.0 introduced a new approach to add content to a window: the window\r\n",(0,i.jsx)(t.strong,{children:"page"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["A window page is instantiated by the ",(0,i.jsx)(t.code,{children:"WindowPage"})," class and it has a method\r\ncalled ",(0,i.jsx)(t.code,{children:"setContent()"})," that accepts a table of frames that will be\r\n",(0,i.jsx)(t.strong,{children:"automatically positioned"})," in the page content area from top to bottom and\r\nwidth that's bound to the window width."]}),"\n",(0,i.jsx)(t.p,{children:"That way, addons can add frames to the window content without worrying about\r\npositioning them as long as they pass the frames in the right order."}),"\n",(0,i.jsxs)(t.p,{children:['It\'s possible to create multiple pages, one per addon feature, like a settings\r\npage, another one for the main addon content, an "about" page, etc. And then\r\nonce a page is created, it can be sent to the window by calling the\r\n',(0,i.jsx)(t.code,{children:"Window:addPage()"})," method."]}),"\n",(0,i.jsxs)(t.p,{children:["Considering that every window page must be created with a page id, it's just a\r\nmatter of calling ",(0,i.jsx)(t.code,{children:"Window:setActivePage(pageId)"})," to show the right page."]}),"\n",(0,i.jsxs)(t.admonition,{title:"Free inner frames layout",type:"info",children:[(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"What if my addon needs to add inner frames freely that don't behave as\r\nblocks?"})}),(0,i.jsxs)(t.p,{children:["It's totally possible, as\r\nthe ",(0,i.jsx)(t.code,{children:"contentFrame"})," is a public property of the ",(0,i.jsx)(t.code,{children:"WindowPage"})," class and can be\r\nused to position frames. The ",(0,i.jsx)(t.code,{children:"setContent()"})," method is just a helper to add\r\nframes as blocks, but it's not mandatory to use it."]}),(0,i.jsxs)(t.p,{children:["It's totally fine to use ",(0,i.jsx)(t.code,{children:"contentFrame"})," as a parent and relative point to add\r\nframes that don't need to be stacked vertically."]})]}),"\n",(0,i.jsx)(t.p,{children:"See this example on how to add inner frames that behave as blocks to the\r\nwindow content area:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",children:"local window = library\r\n    :new('Window', 'my-window')\r\n    :create()\r\n\r\n-- just a simple component factory to create edit boxes and place them in the\r\n-- pages content area, but it works for any kind of frame\r\nlocal function getEditBox(text)\r\n   local editBox = CreateFrame('EditBox')\r\n   editBox:SetMultiLine(true)\r\n   editBox:SetSize(100, 100)\r\n   editBox:SetPoint('TOP', 0, 0)\r\n   editBox:SetFontObject(GameFontNormal)\r\n   editBox:SetText(text)\r\n   editBox:SetAutoFocus(false)\r\n   editBox:SetTextInsets(10, 10, 0, 0)\r\n   editBox:SetEnabled(false)\r\n   editBox:Show()\r\n   return editBox\r\nend\r\n\r\n-- the :create() method must be called before adding content as the\r\n-- window content area is created by this method and won't be triggered\r\n-- by the class constructor\r\nlocal settPage = library:new('WindowPage', 'settings'):create()\r\nlocal mainPage = library:new('WindowPage', 'main'):create()\r\n\r\nsettPage:setContent({\r\n    getEditBox('Settings page'),\r\n    getEditBox('Setting#1'),\r\n    getEditBox('Setting#2'),\r\n})\r\nmainPage:setContent({\r\n    getEditBox('Main addon content page'),\r\n    getEditBox('Component#1'),\r\n    getEditBox('Component#2'),\r\n})\r\n\r\nwindow:addPage(settPage)\r\nwindow:addPage(mainPage)\r\n\r\n-- this is optional, but allows testing the window with easy chat commands\r\n_G['myWindow'] = window\r\n\r\n-- shows the settings page\r\nmyWindow:setActivePage('settings')\r\n\r\n-- shows the main page\r\nmyWindow:setActivePage('main')\n"})}),"\n",(0,i.jsxs)(t.admonition,{title:"Keep an eye on this documentation",type:"note",children:[(0,i.jsx)(t.p,{children:"The philosophy behind the library is to grow organically based on addons\r\ndemands and developers feedback."}),(0,i.jsxs)(t.p,{children:["It's most likely that the ",(0,i.jsx)(t.code,{children:"Window"})," class will have more features in the future\r\nand this documentation will be updated to reflect those changes. Make sure to\r\ncheck the ",(0,i.jsx)(t.a,{href:"../../changelog",children:"changelog"})," frequently to see what's new."]})]}),"\n",(0,i.jsx)(t.h2,{id:"window-persistent-state",children:"Window persistent state"}),"\n",(0,i.jsxs)(t.p,{children:["On the example above, look at ",(0,i.jsx)(t.code,{children:"id"})," parameter passed to the ",(0,i.jsx)(t.code,{children:"Window"}),"\r\nconstructor. This id is used to persist the window state between interface\r\nreloads and that's automatically done by the library. However, for that to\r\nwork, the window id must be unique, and the library must be instantiated with the ",(0,i.jsx)(t.code,{children:"data"})," property (",(0,i.jsx)(t.a,{href:"../core/addon-properties#data",children:"read more about that here"}),")."]}),"\n",(0,i.jsxs)(t.p,{children:["In case the addon passes the ",(0,i.jsx)(t.code,{children:"data"})," property to the library initialization,\r\nit will have a ",(0,i.jsx)(t.a,{href:"../core/configuration",children:"configuration manager"})," that will store\r\nthe window size, position, visibility, etc, between interface reloads."]}),"\n",(0,i.jsxs)(t.p,{children:["That's why most of the setters start with ",(0,i.jsx)(t.code,{children:"setFirst"})," instead of just ",(0,i.jsx)(t.code,{children:"set"}),'.\r\nBecause that means the library will use the first value set to the window for\r\nits initial state. After that, the window state will be managed by the\r\nlibrary configuration manager. Which means, at the moment a player moves,\r\nresizes, closes, etc, the window, it will save its state in a saved variable\r\nmanaged by the library configuration instance and once the frame is shown\r\nagain, the "first values" will be ignored and the ones saved will be used.']}),"\n",(0,i.jsxs)(t.p,{children:["By default, the window state will be saved in the global context, meaning that\r\nplayers will share the same window state. However, the library allows the\r\naddon to save the window state in the character context by calling\r\n",(0,i.jsx)(t.code,{children:"Window:setPersistStateByPlayer(true)"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",children:"-- if a player changes the window size, position, visibility, etc, the window\r\n-- state will be reflected for any other players in the same account\r\nlocal sharedWindow = library\r\n    :new('Window', 'window-id')\r\n    :create()\r\n\r\n-- in this case, the window state will be saved for each player separately\r\nlocal playerWindow = library\r\n    :new('Window', 'window-id')\r\n    :setPersistStateByPlayer(true)\r\n    :create()\n"})}),"\n",(0,i.jsxs)(t.admonition,{title:"Set persistence before creating the window",type:"warning",children:[(0,i.jsxs)(t.p,{children:["Due to how windows are built and have their properties managed, the\r\n",(0,i.jsx)(t.code,{children:"create()"})," method will get the state before rendering the frames."]}),(0,i.jsxs)(t.p,{children:["That means that\r\nthe ",(0,i.jsx)(t.code,{children:"setPersistStateByPlayer()"})," method must be called before ",(0,i.jsx)(t.code,{children:"create()"}),",\r\notherwise, the window state will be initially loaded from the global context\r\nand then persisted in the player context, having no effects on subsequent\r\ninterface reloads."]})]})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(6540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);