"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[3874],{3532:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var n=s(4848),r=s(8453);const a={},i="Test Classes",l={id:"testing/test-classes",title:"Test Classes",description:"Test classes in the Stormwind Library are organized in a way that makes it",source:"@site/docs/testing/test-classes.md",sourceDirName:"testing",slug:"/testing/test-classes",permalink:"/docs/testing/test-classes",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/testing/test-classes.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"API Mocks",permalink:"/docs/testing/api-mocks"},next:{title:"Unit Suite",permalink:"/docs/testing/unit-suite"}},o={},c=[{value:"Writing a test class",id:"writing-a-test-class",level:2},{value:"Working with test cases",id:"working-with-test-cases",level:2},{value:"Getting the library instance in a test case",id:"getting-the-library-instance-in-a-test-case",level:2},{value:"Mocking library properties and methods",id:"mocking-library-properties-and-methods",level:2},{value:"Spies",id:"spies",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"test-classes",children:"Test Classes"}),"\n",(0,n.jsx)(t.p,{children:"Test classes in the Stormwind Library are organized in a way that makes it\r\neasy to run all tests at once although split into multiple files for each\r\nclass in the src directory."}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"./tests/unit.lua"})," file is the entry point for running all tests and it\r\nalso defines a base test class that sets up the library before each test.\r\nSetting up the library before each test ensures that the library is in a\r\nclean state before each test is run, so mocking the library on tests won't\r\naffect the results of other tests."]}),"\n",(0,n.jsx)(t.h2,{id:"writing-a-test-class",children:"Writing a test class"}),"\n",(0,n.jsx)(t.p,{children:"In order to write a test class, it's highly recommended to follow a couple\r\nof standards to keep the tests organized, easy to read, and easy to\r\nmaintain."}),"\n",(0,n.jsx)(t.p,{children:"As an example, consider the support classes in the library as they are good\r\nrepresentatives of how a test class should be written."}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Start by creating a directory following the same structure as the src\r\ndirectory, but inside tests"}),"\n",(0,n.jsx)(t.li,{children:"Create a test file for each class in the src directory"}),"\n",(0,n.jsxs)(t.li,{children:["Define the test class starting with the ",(0,n.jsx)(t.strong,{children:"Test"})," prefix followed by the\r\nname of the class being tested; this is important for the test runner to\r\nidentify the test class, otherwise it will be skipped"]}),"\n",(0,n.jsxs)(t.li,{children:["Define a method for each test case starting with the ",(0,n.jsx)(t.strong,{children:"test"})," prefix"]}),"\n",(0,n.jsxs)(t.li,{children:["Update the ",(0,n.jsx)(t.code,{children:"./tests/unit.lua"})," file to include the test file, preferably\r\nin alphabetical order"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["See ",(0,n.jsx)(t.a,{href:"../resources/core/classes#class-recipe",children:"this example"})," of how a test class\r\nis structured."]}),"\n",(0,n.jsx)(t.h2,{id:"working-with-test-cases",children:"Working with test cases"}),"\n",(0,n.jsxs)(t.p,{children:["Stormwind Library version 1.11.0 introduced a new way to write test cases by providing\r\na test class that allows multiple scenarios to be tested in a single test body. It was\r\ninitially added to ",(0,n.jsx)(t.code,{children:"tests\\unit.lua"})," but may be moved in the future in case a test\r\nlibrary is created."]}),"\n",(0,n.jsxs)(t.p,{children:["By the way, ",(0,n.jsx)(t.code,{children:"tests\\unit.lua"})," can be copied to the addon's test directory and updated\r\nto serve as the entry point for running all tests there as well."]}),"\n",(0,n.jsxs)(t.p,{children:["A test case is a simple class that contains a few chained setters and a register\r\nmethod. Once called and configured, the register method will add a new method prefixed\r\nwith ",(0,n.jsx)(t.code,{children:"test"})," so the testing library can identify it as a test case. In other words, it\r\nworks similarly as writing multiple test methods in a table."]}),"\n",(0,n.jsxs)(t.p,{children:["By the time of writing this documentation, Stormwind Library uses\r\n",(0,n.jsx)(t.a,{href:"../testing/unit-suite",children:"luaunit"})," as the main testing library, so all test cases must\r\nbe created as methods prefixed with ",(0,n.jsx)(t.code,{children:"test"})," in tables that also start with the ",(0,n.jsx)(t.code,{children:"Test"}),"\r\nprefix."]}),"\n",(0,n.jsx)(t.p,{children:"That said, for methods with conditionals and multiple possible outcomes, it's\r\nrecommended to share the same test body. However, having multiple assertions for each\r\nscenario can be a bit confusing to identify when they break. So it's recommended to\r\nhave atomic assertions for each scenario."}),"\n",(0,n.jsx)(t.p,{children:"Here's an example of how to write a test case with multiple scenarios:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-lua",children:"TestMyCustomClass = BaseTestClass:new()\r\n\r\nTestCase.new()\r\n   :setName('add')\r\n   :setTestClass(TestMyCustomClass)\r\n   :setExecution(function(data)\r\n      local handler = {'imagine a handler class here...'}\r\n      handler:add(data.value)\r\n      lu.assertTrue(data.expectedResult, handler:getAddedValues())\r\n   end)\r\n   :setScenarios({\r\n      ['adding nil values'] = {\r\n         value = nil,\r\n         expectedResult = {}\r\n      },\r\n      ['adding a number'] = function ()\r\n         local something = _G['someCustomTable']:getSomething()\r\n         return {\r\n            value = something,\r\n            expectedResult = {something}\r\n         }\r\n      end,\r\n   })\r\n   :register()\n"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The test name can be anything that identifies the test case and must be unique"}),"\n",(0,n.jsx)(t.li,{children:"The test class must be the table instantiated in the test file"}),"\n",(0,n.jsx)(t.li,{children:"The execution method is where the test body is defined"}),"\n",(0,n.jsxs)(t.li,{children:["Scenarios is a table with multiple scenarios that will be sent to the test body\r\nas the ",(0,n.jsx)(t.code,{children:"data"})," argument"]}),"\n",(0,n.jsxs)(t.li,{children:["The register method will add a new method prefixed with ",(0,n.jsx)(t.code,{children:"test"})," to the test class\r\nfor each scenario"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Based on the example above, when executing the tests for ",(0,n.jsx)(t.code,{children:"TestMyCustomClass"}),", two\r\ntest methods will be created, one for each scenario, which also desires a few notes:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["The scenarios setter is not required, so it's possible to have a test case with\r\nonly one default scenario. Just omit the ",(0,n.jsx)(t.code,{children:"setScenarios()"})," call and remove the ",(0,n.jsx)(t.code,{children:"data"}),"\r\nparameter from the execution method."]}),"\n",(0,n.jsx)(t.li,{children:"Each scenario must have a unique name, otherwise they may overwrite each other"}),"\n",(0,n.jsxs)(t.li,{children:["Note that scenarios can be defined as tables or functions in the example above:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["When they are tables, the test body will receive the table as the ",(0,n.jsx)(t.code,{children:"data"})," parameter"]}),"\n",(0,n.jsxs)(t.li,{children:["When they are functions, the test body will receive the return of the function as\r\nthe ",(0,n.jsx)(t.code,{children:"data"})," parameter. This is useful when the scenario needs to access structures\r\nthat are available only at runtime, after the test setup."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"getting-the-library-instance-in-a-test-case",children:"Getting the library instance in a test case"}),"\n",(0,n.jsxs)(t.p,{children:["A library instance is available in each test case through the global\r\nvariable ",(0,n.jsx)(t.code,{children:"__"})," and it's ready to be used without any further setup. However,\r\nif a test case requires a different setup, it's possible to instantiate a\r\nnew library instance in the test case by doing this:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-lua",children:"local __ = StormwindLibrary.new({\r\n    name = 'TestSuite'\r\n})\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In the example above, ",(0,n.jsx)(t.code,{children:"StormwindLibrary"})," is an alias for the library version\r\nbeing tested, so when new versions are released, it's only necessary to\r\nupdate the alias in the ",(0,n.jsx)(t.code,{children:"./tests/unit.lua"})," file."]}),"\n",(0,n.jsx)(t.h2,{id:"mocking-library-properties-and-methods",children:"Mocking library properties and methods"}),"\n",(0,n.jsx)(t.p,{children:"A library instance is set up before each test in the base test class and also before\r\neach scenario when the test case class is used. That said, mocking properties and\r\nmethods of the library can be done in each test execution without affecting other\r\ntests."}),"\n",(0,n.jsxs)(t.p,{children:["To mock a property or method in this instance, simply assign a new value to\r\nthe property or method in the test case. For example, to mock the addon ",(0,n.jsx)(t.code,{children:"name"}),",\r\nyou can do the following:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-lua",children:"__.addon.name = 'MockedName'\n"})}),"\n",(0,n.jsx)(t.p,{children:"To mock a method library, you can assign a new function to do and/or return what\r\nyou expect to help the test case."}),"\n",(0,n.jsx)(t.p,{children:"There's no need to revert the mocked properties and methods back to their\r\noriginal values after the test case is run, unless the test method is\r\nexpected to be called multiple times in the same test class and with\r\ndifferent mocks, however, that's a sign that a test case should be created\r\nwith multiple scenarios instead."}),"\n",(0,n.jsxs)(t.p,{children:["Stormwind Library also provides a set of mocks for the World of Warcraft API\r\nthat are better described in the ",(0,n.jsx)(t.a,{href:"api-mocks",children:"API Mocks"})," documentation."]}),"\n",(0,n.jsx)(t.h3,{id:"spies",children:"Spies"}),"\n",(0,n.jsx)(t.p,{children:"Spies are a type of mock that allows you to replace a few parts of objects to track\r\nhow they are being used. Of course, the concept of spies are way more complex than\r\nthis, but Stormwind Library implements a simple version of it. It was introduced in\r\nv1.12.0 as an experimental feature that may be improved in the future."}),"\n",(0,n.jsxs)(t.p,{children:["As of now, the two spy classes available are ",(0,n.jsx)(t.code,{children:"Spy"})," and ",(0,n.jsx)(t.code,{children:"MethodSpy"}),", both located in\r\n",(0,n.jsx)(t.code,{children:"tests\\spies.lua"}),". This file can be copied to the addon's test directory and\r\nreferenced with ",(0,n.jsx)(t.code,{children:"dofile"})," so they can be used in test cases."]}),"\n",(0,n.jsxs)(t.p,{children:["You probably won't need to use ",(0,n.jsx)(t.code,{children:"MethodSpy"})," directly as it's more like a utility class\r\nfor ",(0,n.jsx)(t.code,{children:"Spy"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["As an example, consider a class called ",(0,n.jsx)(t.code,{children:"EndGameFeatures"})," with a couple of methods\r\nfor handling end game features."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-lua",children:"-- class declaration...\r\nEndGameFeatures = {}\r\n   -- other methods here...\r\n\r\n   function EndGameFeatures:getPlayerLevel()\r\n      return UnitLevel('player')\r\n   end\r\n\r\n   function EndGameFeatures:playerIsAtMaxLevel()\r\n      return self:getPlayerLevel() == MAX_PLAYER_LEVEL\r\n   end\r\n   \r\n   -- more methods here...\n"})}),"\n",(0,n.jsxs)(t.p,{children:["When testing this class, you may want to mock the ",(0,n.jsx)(t.code,{children:"UnitLevel"})," function to return a\r\nspecific value to serve the ",(0,n.jsx)(t.code,{children:"getPlayerLevel"})," method. And in another method, you may\r\nwamt to mock ",(0,n.jsx)(t.code,{children:"getPlayerLevel"})," to return a specific value to test\r\n",(0,n.jsx)(t.code,{children:"playerIsAtMaxLevel"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"This can be done directly by replacing the function references like this:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-lua",children:"TestCase.new()\r\n   :setName('playerIsAtMaxLevel')\r\n   :setTestClass(TestEndGameFeatures)\r\n   :setExecution(function(data)\r\n      local instance = library:new('EndGameFeatures')\r\n\r\n      instance.getPlayerLevel = function()\r\n         return data.playerLevel\r\n      end\r\n\r\n      lu.assertEquals(data.expectedResult, instance:playerIsAtMaxLevel())\r\n   end)\r\n   :setScenarios({\r\n      ['player is at max level'] = {\r\n         playerLevel = 60,\r\n         expectedResult = true\r\n      },\r\n      ['player not at max level'] = {\r\n         playerLevel = 59,\r\n         expectedResult = false\r\n      }\r\n   })\r\n   :register()\n"})}),"\n",(0,n.jsx)(t.p,{children:"It works as a valid test, but with spies, it can be improved to track how the method\r\nis observed. Here's how to do it:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-lua",children:"TestCase.new()\r\n   :setName('playerIsAtMaxLevel')\r\n   :setTestClass(TestEndGameFeatures)\r\n   :setExecution(function(data)\r\n      local instance = Spy\r\n         .new(library:new('EndGameFeatures'))\r\n         :mockMethod('getPlayerLevel', function()\r\n            return data.playerLevel\r\n         end)\r\n\r\n      local result = instance:playerIsAtMaxLevel()\r\n\r\n      lu.assertEquals(data.expectedResult, result)\r\n      instance:getMethod('getPlayerLevel'):assertCalledOnce()\r\n   end)\r\n   :setScenarios({\r\n      ['player is at max level'] = {\r\n         playerLevel = 60,\r\n         expectedResult = true\r\n      },\r\n      ['player not at max level'] = {\r\n         playerLevel = 59,\r\n         expectedResult = false\r\n      }\r\n   })\r\n   :register()\n"})}),"\n",(0,n.jsx)(t.p,{children:"This is what the test execution does:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["Create a new spy instance passing the ",(0,n.jsx)(t.code,{children:"EndGameFeatures"})," instance"]}),"\n",(0,n.jsx)(t.li,{children:"Once wrapped, the spy instance can mock methods and properties and the mock\r\nmethods are chained, which means it's possible to mock multiple methods one\r\nafter another and still hold the reference to the spy instance"}),"\n",(0,n.jsxs)(t.li,{children:["Call the ",(0,n.jsx)(t.code,{children:"instance:playerIsAtMaxLevel()"})," method and store the result"]}),"\n",(0,n.jsx)(t.li,{children:"Assert the result is the expected one"}),"\n",(0,n.jsxs)(t.li,{children:["Assert the ",(0,n.jsx)(t.code,{children:"getPlayerLevel"})," method was called once, and this is the main\r\nadvantage of using spies, as it allows you to track how the method is being\r\nused"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"MethodSpy"})," class has a few more assertions that use the same unit testing\r\nlibrary, so it's not necessary to call ",(0,n.jsx)(t.code,{children:"lu.assertEquals"})," and similar functions\r\non the methods spies instances."]}),"\n",(0,n.jsx)(t.admonition,{title:"Mocking functions stored as properties",type:"note",children:(0,n.jsx)(t.p,{children:"Due to how this first Spy version is implemented, functions that are saved as\r\nproperties cannot be mocked as a \"class method\". Example: a class has a callback\r\nstored as a property, and the callback is called inside a method. It's not\r\npossible to mock the callback and expect that Spy will create a method spy\r\nfor it as it won't have the same behavior as a class method."})}),"\n",(0,n.jsxs)(t.admonition,{title:"Use spies carefully",type:"warning",children:[(0,n.jsx)(t.p,{children:"It's important to mention that as of now, spies are still an experimental feature\r\nand may not work as expected in all scenarios. It's recommended to use them\r\ncarefully and review the test results to ensure they are working as expected."}),(0,n.jsxs)(t.p,{children:["If you find any issues with spies, please report them in the\r\n",(0,n.jsx)(t.a,{href:"https://github.com/adrianocastro189/stormwind-library/issues",children:"library's repository issues page"}),"."]})]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>l});var n=s(6540);const r={},a=n.createContext(r);function i(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);