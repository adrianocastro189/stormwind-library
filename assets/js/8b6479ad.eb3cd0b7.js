"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[3032],{2130:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>l});var s=n(4848),i=n(8453);const r={},a="Settings",d={id:"resources/core/settings",title:"Settings",description:"Settings are basically configuration values that can be manipulated",source:"@site/docs/resources/core/settings.md",sourceDirName:"resources/core",slug:"/resources/core/settings",permalink:"/docs/resources/core/settings",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/resources/core/settings.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Output",permalink:"/docs/resources/core/output"},next:{title:"Facades",permalink:"/docs/category/facades"}},o={},l=[{value:"Usage",id:"usage",level:2},{value:"Getting and setting values",id:"getting-and-setting-values",level:2},{value:"Setting Groups",id:"setting-groups",level:2},{value:"The Settings class",id:"the-settings-class",level:2},{value:"Settings via addon properties",id:"settings-via-addon-properties",level:2},{value:"Commands integration",id:"commands-integration",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"settings",children:"Settings"})}),"\n",(0,s.jsxs)(t.p,{children:["Settings are basically ",(0,s.jsx)(t.a,{href:"configuration",children:"configuration"})," values that can be manipulated\r\nby players with chat commands and UI elements."]}),"\n",(0,s.jsx)(t.p,{children:"It's important to note that the configuration structure is a base for this class as\r\nit is used to store the settings values for global and player scopes. The reason\r\nthey're separated in two classes is to avoid confusion and handle settings properly."}),"\n",(0,s.jsxs)(t.p,{children:["A good example of the difference between the two: an addon that shows a small window\r\nwith a list of settings that can be toggled on and off. When a player moves this\r\nwindow, resizes it or even closes it, the window state is persisted by the\r\n",(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"configuration",children:"configuration structure"})}),', which means the last position, size and\r\nvisibility are not directly set by players. But when they toggle the settings inside\r\nthis window, the options they see like "Show minimap icon" are stored in the\r\n',(0,s.jsx)(t.strong,{children:"settings structure"}),", described below."]}),"\n",(0,s.jsx)(t.p,{children:"And finally, configurations are only changed programmatically, while settings can be\r\nchanged by players by running chat commands and interacting with UI elements. And\r\nthis is one of the settings motivations when designed: to allow automatic UI elements\r\nto be created from the addon settings."}),"\n",(0,s.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(t.p,{children:"Creating a setting instance is pretty simple and straightforward. Its chained\r\nmethods allow to build a new instance and set its properties in a single call like\r\nthis:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local group = library:new('SettingGroup')\r\n\r\n-- group setters called here\r\n\r\nlocal setting = library:new('Setting')\r\n    :setAccessibleByCommand(true)\r\n    :setDefault('default value')\r\n    :setDescription('This is a setting description')\r\n    :setGroup(group)\r\n    :setId('settingId')\r\n    :setLabel('Setting Label')\r\n    :setScope('player')\r\n    :setType('string')\n"})}),"\n",(0,s.jsxs)(t.admonition,{title:"Data storage",type:"warning",children:[(0,s.jsxs)(t.p,{children:["It's important to note that the code above will work as expected only ",(0,s.jsx)(t.strong,{children:"if the addon\r\ninstantiates the library with a data table set."}),"\r\n",(0,s.jsx)(t.a,{href:"/docs/resources/core/addon-properties#data",children:"Read this"})," for more information as that's the only\r\nway settings will be persisted when players reload the game."]}),(0,s.jsxs)(t.p,{children:["Also, settings must be added to the library settings instance ",(0,s.jsx)(t.strong,{children:"after"})," the\r\n",(0,s.jsx)(t.code,{children:"PLAYER_LOGIN"})," event is triggered. This is because the library data table must be\r\nalready loaded, otherwise settings won't be persisted. If you are not sure about the\r\ntiming your addon settings are being added, consider configuring settings with\r\n",(0,s.jsx)(t.a,{href:"#settings-via-addon-properties",children:"addon properties"}),", which is the safest and easiest\r\nway."]})]}),"\n",(0,s.jsx)(t.p,{children:"Let's break down the chained methods used in the example above:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"setAccessibleByCommand"}),": sets whether the setting can be changed by players using\r\nchat commands. It defaults to ",(0,s.jsx)(t.code,{children:"true"})," when not called."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"setDefault"}),": sets the default value for the setting. When the setting value is\r\nretrieved and it's not set, this value will be returned. If not informed, it will\r\ndefault to ",(0,s.jsx)(t.code,{children:"nil"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"setDescription"}),": sets the setting description. It's used by the library in any\r\nvisual representation of the setting like UI elements and chat command outputs."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"setGroup"}),": sets the setting group. It's used to group settings in the UI elements\r\nand also to build the setting fully qualified id."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"setId"}),": sets the setting id. It's used to identify the setting and must be unique\r\n",(0,s.jsx)(t.strong,{children:"within the group."})," Which means two settings may have the same id as long as they\r\nbelong to different groups."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"setLabel"}),": sets the setting label. It's used by the library in any visual\r\nrepresentation of the setting like UI elements."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"setScope"}),": sets the setting scope. It can be either ",(0,s.jsx)(t.code,{children:"global"})," or ",(0,s.jsx)(t.code,{children:"player"}),". The\r\nglobal settings are shared among all players, while player settings are unique for\r\neach player. The ",(0,s.jsx)(t.code,{children:"Setting"})," class has constants for these values so devs don't need\r\nto hardcode them."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"setType"}),": sets the setting type. Although the library doesn't enforce type\r\nchecking, it's important to set it correctly as it's used by the library in any\r\nforms of visual representation of the setting to let players know what kind of\r\nvalue they're dealing with. The ",(0,s.jsx)(t.code,{children:"Setting"})," class has constants for these values so\r\ndevs don't need to hardcode them."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"getting-and-setting-values",children:"Getting and setting values"}),"\n",(0,s.jsx)(t.p,{children:"Once a setting is instantiated, it can be used to get and set a value to be persisted\r\nin the addon's data table."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local setting = -- setting instantiation here\r\n\r\n-- setting value\r\nsetting:setValue('my value')\r\n\r\n-- the code above will store 'my value' in the addon's data table's\r\n-- global or player scope, depending on the setting scope\r\n\r\n-- getting the value\r\nlocal value = setting:getValue()\n"})}),"\n",(0,s.jsxs)(t.p,{children:["When updating a value (changing it with a new value, different from the current one),\r\nthe library will trigger the ",(0,s.jsx)(t.code,{children:"SETTING_UPDATED"}),"\r\n",(0,s.jsx)(t.a,{href:"/docs/resources/facades/events#setting_updated",children:"event"})," and the payload will contain the\r\nsetting ",(0,s.jsx)(t.strong,{children:"fully qualified id"}),", ",(0,s.jsx)(t.strong,{children:"old value"})," and ",(0,s.jsx)(t.strong,{children:"new value"}),". Which means that\r\naddons can watch for this event and react to setting changes like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"library.events:listen('SETTING_UPDATED', function(id, oldValue, newValue)\r\n    -- do something with the setting change here\r\nend)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["It's also possible to use the ",(0,s.jsx)(t.code,{children:"Setting:isTrue()"})," method when dealing with boolean\r\nsettings in many formats like ",(0,s.jsx)(t.code,{children:"1"}),", ",(0,s.jsx)(t.code,{children:"true"}),", ",(0,s.jsx)(t.code,{children:"yes"})," and a few more covered by\r\n",(0,s.jsx)(t.a,{href:"../support/bool",children:"Bool"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"setting-groups",children:"Setting Groups"}),"\n",(0,s.jsxs)(t.p,{children:["Settings in Stormwind Library were designed to ",(0,s.jsx)(t.strong,{children:"always belong to groups."})," The\r\nreason for this is to have it prepared for a second phase in this structure where\r\nsettings will be automatically converted into UI elements for auto generated settings\r\n",(0,s.jsx)(t.a,{href:"../views/window#adding-content-to-the-window",children:"pages"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Although not available yet in v1.13.0 (as of this writing), by creating settings\r\nwith groups in mind, the impact of this resource will be minimal when the feature is\r\nreleased."}),"\n",(0,s.jsx)(t.p,{children:"Groups can be easily instantiated and set up like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local group = library\r\n    :new('SettingGroup')\r\n    :setId('groupId')\r\n    :setLabel('Group Label')\n"})}),"\n",(0,s.jsx)(t.p,{children:"After that, settings can be added to it:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local setting = library\r\n    :new('Setting')\r\n    :setID('settingId')\r\n    \r\ngroup:addSetting(setting)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Once a setting is added to a group, it's fully qualified id will be built using the\r\ngroup id and the setting id. Using the example above, it will be ",(0,s.jsx)(t.code,{children:"groupId.settingId"}),".\r\nThat's the id that will be used by addons to retrieve settings instances and, of\r\ncourse, their values."]}),"\n",(0,s.jsx)(t.h2,{id:"the-settings-class",children:"The Settings class"}),"\n",(0,s.jsxs)(t.p,{children:["When the library is instantiated, it may create a ",(0,s.jsx)(t.code,{children:"Settings"})," instance in case a data\r\ntable ",(0,s.jsx)(t.a,{href:"../core/addon-properties#data",children:"has been set"}),". This instance is accessible\r\nby the ",(0,s.jsx)(t.code,{children:"settings"})," property in the library table root and it's used to handle all\r\naddon settings."]}),"\n",(0,s.jsx)(t.p,{children:"Addons must start by creating setting groups:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local groupA = library\r\n    :new('SettingGroup')\r\n    :setId('groupA')\r\n    :setLabel('Group A')\r\n\r\nlocal groupB = -- instantiate group B here\r\nlocal groupC = -- instantiate group C here and so on\n"})}),"\n",(0,s.jsx)(t.p,{children:"After that, settings can be added to these groups:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"local settingA = -- instantiate setting A here\r\nlocal settingB = -- instantiate setting B here and so on\r\n\r\ngroupA:addSetting(settingA)\r\ngroupB:addSetting(settingB)\n"})}),"\n",(0,s.jsx)(t.p,{children:"And finally, the groups can be added to the settings instance:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"library.settings:addSettingGroup(groupA)\r\nlibrary.settings:addSettingGroup(groupB)\n"})}),"\n",(0,s.jsx)(t.p,{children:"Alternatively, settings can be added directly to the settings instance:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"library.settings:addSetting(settingA, 'groupA')\r\nlibrary.settings:addSetting(settingB, 'groupB')\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Note that in this case, the group id must be passed as the second argument to the\r\n",(0,s.jsx)(t.code,{children:"addSetting"})," method. In case it's not passed, the library will assume the setting is\r\nbeing added to the default group, which is called ",(0,s.jsx)(t.strong,{children:"General"})," (id = ",(0,s.jsx)(t.code,{children:"general"}),")."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"-- adding settingA to the general group\r\nlibrary.settings:addSetting(settingA)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Once the settings are added to the settings instance, they're already part of the\r\naddon settings and can be retrieved by their ",(0,s.jsx)(t.strong,{children:"fully qualified id:"})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"-- this will return the Setting A instance which is in Group A\r\nlocal setting = library.settings:getSetting('groupA.settingA')\r\n\r\n-- this will return the Setting B instance which is in the general group\r\nlocal setting = library.settings:getSetting('settingB')\n"})}),"\n",(0,s.jsxs)(t.admonition,{type:"warning",children:[(0,s.jsxs)(t.mdxAdmonitionTitle,{children:["Settings",":setting","() returns an instance, not a value"]}),(0,s.jsxs)(t.p,{children:["Please, note that the ",(0,s.jsx)(t.code,{children:"Settings:setting()"})," method returns the setting instance, not\r\nits stored value. To get the value, use result's ",(0,s.jsx)(t.code,{children:"getValue()"})," method, but remember\r\nthat the instance can be nil for invalid settings, which means a conditional may be\r\nrequired."]})]}),"\n",(0,s.jsx)(t.p,{children:"A shortcut is also available to get setting instances by their fully qualified id:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"-- this will return the same as library.settings:setting('groupA.settingA')\r\nlocal setting = library:setting('groupA.settingA')\n"})}),"\n",(0,s.jsx)(t.h2,{id:"settings-via-addon-properties",children:"Settings via addon properties"}),"\n",(0,s.jsx)(t.p,{children:"Up to this point, it was described how to programmatically create settings in an\r\naddon and it may work for most cases."}),"\n",(0,s.jsxs)(t.p,{children:["But there's a more straightforward way to do the same with less code and to have\r\nsettings automatically generated by the library once the addon is instantiated. This\r\nis done by using ",(0,s.jsx)(t.a,{href:"../core/addon-properties",children:"addon properties"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Here's an example of how to set up settings using addon properties. Notice that it\r\nexpects the same class properties as both ",(0,s.jsx)(t.code,{children:"SettingGroup"})," and ",(0,s.jsx)(t.code,{children:"Setting"})," classes:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:"MyAddon.__ = StormwindLibrary.new({\r\n    name = 'My Custom Addon',\r\n    -- other addon properties here\r\n    settings = {\r\n        groups = {\r\n            {\r\n                id = 'group-a',\r\n                label = 'Group A',\r\n                settings = {\r\n                    {\r\n                        id = 'setting-a',\r\n                        label = 'Setting A',\r\n                        description = 'This is setting A',\r\n                        type = 'string',\r\n                        default = 'default value',\r\n                        scope = 'player',\r\n                        accessibleByCommand = true\r\n                    },\r\n                    {\r\n                        id = 'setting-b',\r\n                        label = 'Setting B',\r\n                        description = 'This is setting B',\r\n                        type = 'boolean',\r\n                        default = true,\r\n                        scope = 'global',\r\n                        accessibleByCommand = true\r\n                    }\r\n                    -- other settings here\r\n                },\r\n            },\r\n            -- other groups here\r\n        }\r\n    }\r\n})\n"})}),"\n",(0,s.jsx)(t.p,{children:"If the groups and settings adhere to the structure above, once instantiated, the\r\naddon will automatically create and handle them just like the manual setup described\r\nin the previous sections."}),"\n",(0,s.jsxs)(t.admonition,{title:"General groups with addon properties",type:"note",children:[(0,s.jsxs)(t.p,{children:["As described in this page, settings ",(0,s.jsx)(t.strong,{children:"may belong to a setting group"})," and in case\r\nthey're added without one, the ",(0,s.jsx)(t.code,{children:"general"})," group will be used instead."]}),(0,s.jsxs)(t.p,{children:["When using addon properties, it's important to group settings properly to avoid\r\nparsing errors. And even if no ",(0,s.jsx)(t.code,{children:"general"})," group is set by the developer, if adding\r\nsettings with addon properties and then later adding settings programmatically\r\nwithout a group, the library will automatically create a ",(0,s.jsx)(t.code,{children:"general"})," group anyway."]})]}),"\n",(0,s.jsx)(t.h2,{id:"commands-integration",children:"Commands integration"}),"\n",(0,s.jsx)(t.p,{children:"Settings were designed to be available by players in two ways, basically:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Chat commands"}),"\n",(0,s.jsx)(t.li,{children:"UI (this will be released in future versions)"}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["When it comes to chat commands, the ",(0,s.jsx)(t.a,{href:"../commands/overview",children:"commands structure"}),"\r\nis already prepared to create default operations for listing available settings,\r\ngetting and updating their values."]}),"\n",(0,s.jsxs)(t.p,{children:["All you need to do is create settings that accessible by command and have a\r\n",(0,s.jsx)(t.a,{href:"../core/addon-properties#command",children:"command alias set to your addon"}),". The rest\r\nis automatically handled by the library."]}),"\n",(0,s.jsxs)(t.p,{children:["Imagine you have an addon created with ",(0,s.jsx)(t.code,{children:"myaddon"})," as the command alias and the\r\nsame settings as the ",(0,s.jsx)(t.a,{href:"#settings-via-addon-properties",children:"example above"}),". Once the\r\ngame is loaded, players can use the following command to list all settings\r\nthey can change like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"/myaddon settings\n"})}),"\n",(0,s.jsx)(t.p,{children:"This will output a list similar to:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"group-a.setting-a <string> This is setting A\r\ngroup-a.setting-b <boolean> This is setting B\n"})}),"\n",(0,s.jsx)(t.p,{children:"Players can get the current value of a setting by running:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"/myaddon get group-a.setting-a\n"})}),"\n",(0,s.jsx)(t.p,{children:"And update it by running:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'/myaddon set group-a.setting-a "new value"\r\n/myaddon set group-a.setting-b true\n'})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>d});var s=n(6540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);