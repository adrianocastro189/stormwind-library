"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[3874],{3532:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var n=s(4848),r=s(8453);const i={},a="Test Classes",o={id:"testing/test-classes",title:"Test Classes",description:"Test classes in the Stormwind Library are organized in a way that makes it",source:"@site/docs/testing/test-classes.md",sourceDirName:"testing",slug:"/testing/test-classes",permalink:"/docs/testing/test-classes",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/testing/test-classes.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"API Mocks",permalink:"/docs/testing/api-mocks"},next:{title:"Unit Suite",permalink:"/docs/testing/unit-suite"}},l={},c=[{value:"Writing a test class",id:"writing-a-test-class",level:2},{value:"Working with test cases",id:"working-with-test-cases",level:2},{value:"Getting the library instance in a test case",id:"getting-the-library-instance-in-a-test-case",level:2},{value:"Mocking library properties and methods",id:"mocking-library-properties-and-methods",level:2}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"test-classes",children:"Test Classes"}),"\n",(0,n.jsx)(t.p,{children:"Test classes in the Stormwind Library are organized in a way that makes it\r\neasy to run all tests at once although split into multiple files for each\r\nclass in the src directory."}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"./tests/unit.lua"})," file is the entry point for running all tests and it\r\nalso defines a base test class that sets up the library before each test.\r\nSetting up the library before each test ensures that the library is in a\r\nclean state before each test is run, so mocking the library on tests won't\r\naffect the results of other tests."]}),"\n",(0,n.jsx)(t.h2,{id:"writing-a-test-class",children:"Writing a test class"}),"\n",(0,n.jsx)(t.p,{children:"In order to write a test class, it's highly recommended to follow a couple\r\nof standards to keep the tests organized, easy to read, and easy to\r\nmaintain."}),"\n",(0,n.jsx)(t.p,{children:"As an example, consider the support classes in the library as they are good\r\nrepresentatives of how a test class should be written."}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Start by creating a directory following the same structure as the src\r\ndirectory, but inside tests"}),"\n",(0,n.jsx)(t.li,{children:"Create a test file for each class in the src directory"}),"\n",(0,n.jsxs)(t.li,{children:["Define the test class starting with the ",(0,n.jsx)(t.strong,{children:"Test"})," prefix followed by the\r\nname of the class being tested; this is important for the test runner to\r\nidentify the test class, otherwise it will be skipped"]}),"\n",(0,n.jsxs)(t.li,{children:["Define a method for each test case starting with the ",(0,n.jsx)(t.strong,{children:"test"})," prefix"]}),"\n",(0,n.jsxs)(t.li,{children:["Update the ",(0,n.jsx)(t.code,{children:"./tests/unit.lua"})," file to include the test file, preferably\r\nin alphabetical order"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["See ",(0,n.jsx)(t.a,{href:"../resources/core/classes#class-recipe",children:"this example"})," of how a test class\r\nis structured."]}),"\n",(0,n.jsx)(t.h2,{id:"working-with-test-cases",children:"Working with test cases"}),"\n",(0,n.jsxs)(t.p,{children:["Stormwind Library version 1.11.0 introduced a new way to write test cases by providing\r\na test class that allows multiple scenarios to be tested in a single test body. It was\r\ninitially added to ",(0,n.jsx)(t.code,{children:"tests\\unit.lua"})," but may be moved in the future in case a test\r\nlibrary is created."]}),"\n",(0,n.jsxs)(t.p,{children:["By the way, ",(0,n.jsx)(t.code,{children:"tests\\unit.lua"})," can be copied to the addon's test directory and updated\r\nto serve as the entry point for running all tests there as well."]}),"\n",(0,n.jsxs)(t.p,{children:["A test case is a simple class that contains a few chained setters and a register\r\nmethod. Once called and configured, the register method will add a new method prefixed\r\nwith ",(0,n.jsx)(t.code,{children:"test"})," so the testing library can identify it as a test case. In other words, it\r\nworks similarly as writing multiple test methods in a table."]}),"\n",(0,n.jsxs)(t.p,{children:["By the time of writing this documentation, Stormwind Library uses\r\n",(0,n.jsx)(t.a,{href:"../testing/unit-suite",children:"luaunit"})," as the main testing library, so all test cases must\r\nbe created as methods prefixed with ",(0,n.jsx)(t.code,{children:"test"})," in tables that also start with the ",(0,n.jsx)(t.code,{children:"Test"}),"\r\nprefix."]}),"\n",(0,n.jsx)(t.p,{children:"That said, for methods with conditionals and multiple possible outcomes, it's\r\nrecommended to share the same test body. However, having multiple assertions for each\r\nscenario can be a bit confusing to identify when they break. So it's recommended to\r\nhave atomic assertions for each scenario."}),"\n",(0,n.jsx)(t.p,{children:"Here's an example of how to write a test case with multiple scenarios:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-lua",children:"TestMyCustomClass = BaseTestClass:new()\r\n\r\nTestCase.new()\r\n   :setName('add')\r\n   :setTestClass(TestMyCustomClass)\r\n   :setExecution(function(data)\r\n      local handler = {'imagine a handler class here...'}\r\n      handler:add(data.value)\r\n      lu.assertTrue(data.expectedResult, handler:getAddedValues())\r\n   end)\r\n   :setScenarios({\r\n      ['adding nil values'] = {\r\n         value = nil,\r\n         expectedResult = {}\r\n      },\r\n      ['adding a number'] = function ()\r\n         local something = _G['someCustomTable']:getSomething()\r\n         return {\r\n            value = something,\r\n            expectedResult = {something}\r\n         }\r\n      end,\r\n   })\r\n   :register()\n"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The test name can be anything that identifies the test case and must be unique"}),"\n",(0,n.jsx)(t.li,{children:"The test class must be the table instantiated in the test file"}),"\n",(0,n.jsx)(t.li,{children:"The execution method is where the test body is defined"}),"\n",(0,n.jsxs)(t.li,{children:["Scenarios is a table with multiple scenarios that will be sent to the test body\r\nas the ",(0,n.jsx)(t.code,{children:"data"})," argument"]}),"\n",(0,n.jsxs)(t.li,{children:["The register method will add a new method prefixed with ",(0,n.jsx)(t.code,{children:"test"})," to the test class\r\nfor each scenario"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Based on the example above, when executing the tests for ",(0,n.jsx)(t.code,{children:"TestMyCustomClass"}),", two\r\ntest methods will be created, one for each scenario, which also desires a few notes:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["The scenarios setter is not required, so it's possible to have a test case with\r\nonly one default scenario. Just omit the ",(0,n.jsx)(t.code,{children:"setScenarios()"})," call and remove the ",(0,n.jsx)(t.code,{children:"data"}),"\r\nparameter from the execution method."]}),"\n",(0,n.jsx)(t.li,{children:"Each scenario must have a unique name, otherwise they may overwrite each other"}),"\n",(0,n.jsxs)(t.li,{children:["Note that scenarios can be defined as tables or functions in the example above:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["When they are tables, the test body will receive the table as the ",(0,n.jsx)(t.code,{children:"data"})," parameter"]}),"\n",(0,n.jsxs)(t.li,{children:["When they are functions, the test body will receive the return of the function as\r\nthe ",(0,n.jsx)(t.code,{children:"data"})," parameter. This is useful when the scenario needs to access structures\r\nthat are available only at runtime, after the test setup."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"getting-the-library-instance-in-a-test-case",children:"Getting the library instance in a test case"}),"\n",(0,n.jsxs)(t.p,{children:["A library instance is available in each test case through the global\r\nvariable ",(0,n.jsx)(t.code,{children:"__"})," and it's ready to be used without any further setup. However,\r\nif a test case requires a different setup, it's possible to instantiate a\r\nnew library instance in the test case by doing this:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-lua",children:"local __ = StormwindLibrary.new({\r\n    name = 'TestSuite'\r\n})\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In the example above, ",(0,n.jsx)(t.code,{children:"StormwindLibrary"})," is an alias for the library version\r\nbeing tested, so when new versions are released, it's only necessary to\r\nupdate the alias in the ",(0,n.jsx)(t.code,{children:"./tests/unit.lua"})," file."]}),"\n",(0,n.jsx)(t.h2,{id:"mocking-library-properties-and-methods",children:"Mocking library properties and methods"}),"\n",(0,n.jsx)(t.p,{children:"The library is set up before each test in the base test class, so mocking\r\nproperties and methods of the library can be done in each test case without\r\naffecting other tests."}),"\n",(0,n.jsxs)(t.p,{children:["To mock a property or method of the library, simply assign a new value to\r\nthe property or method in the test case. For example, to mock the ",(0,n.jsx)(t.code,{children:"name"}),"\r\nproperty of the library, you can do the following:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-lua",children:"__.name = 'MockedName'\n"})}),"\n",(0,n.jsx)(t.p,{children:"To mock a method of the library, you can assign a new function to the\r\nmethod in the test case."}),"\n",(0,n.jsx)(t.p,{children:"There's no need to revert the mocked properties and methods back to their\r\noriginal values after the test case is run, unless the test method is\r\nexpected to be called multiple times in the same test class and with\r\ndifferent mocks."}),"\n",(0,n.jsxs)(t.p,{children:["Stormwind Library also provides a set of mocks for the World of Warcraft API\r\nthat are better described in the ",(0,n.jsx)(t.a,{href:"api-mocks",children:"API Mocks"})," documentation."]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>o});var n=s(6540);const r={},i=n.createContext(r);function a(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);