# Classes

Lua doesn't offer directly a class structure like every
OOP languages like PHP and Java. Because of that, there are
a couple of ways we can emulate classes and effectively be able to
instantiate objects that share logic, property, methods
structure, etc.

The Stormwind Library proposes a few standards to achieve
class structures that are created with a couple of metatables
settings and some indentation.

## Class standards

These are the standards used by Stormwind Library for a table to be
considered a class:

* Each class is defined in its own file, which is later merged to the
single library file
* All lines below the first `local` declaration are indented as
they belong to an opened structure
* Classes have a constructor similar to PHP's, called `__construct()`
* Due to how the library is compiled, when this "class" is being read by
the Lua compiler, the `self` calls are actually referencing the Library
instance, not the class being written -- **only the `self`'s inside
methods refer to the "class" itself**, and because of that, a `self:addClass()`
is called at the top, so the library can store a reference for this "class",
declared as `local`. After that, the library can instantiate that class
anywhere in the addon code.
    * Read the [factory documentation](factory) for more information

:::tip "Private" constructors

Sometimes it's recommended not to expose classes structures for free
instantiation. When that happens, simply don't call `self:addClass()`,
so `library:new()` won't have any effects on it, behaving as a private
constructor, when only the classes themselves can create their own
instances.

As an example, the [raid marker](../models/raid-marker) model has a
limited number of possible instances. That class can't be instantiated
by any addons and its instances are generated by the library during
its initialization.

:::

## Class recipe

Use the recipe below to create new classes.

This is an example of a simple class with no properties.

```lua
--[[--
Class description.

@classmod Module.ClassName
]]
local ClassName = {}
    ClassName.__index = ClassName
    ClassName.__ = self
    self:addClass('ClassName', ClassName)

    --[[--
    ClassName constructor.
    ]]
    function ClassName.__construct()
        local self = setmetatable({}, ClassName)

        -- add properties here

        return self
    end
-- end of ClassName
```

And this is an example of the first test class version for the class above:

```lua
TestClassName = BaseTestClass:new()
    -- @covers ClassName:__construct()
    function TestClassName:testConstruct()
        local instance = __:new('ClassName', --[[ args here ]])

        lu.assertNotNil(instance)
    end
-- end of TestClassName
```

## Models

Models are classes that represent a data structure, like a raid marker,
a player, a macro, an item, etc. They're usually used to hold information
about game objects as a way to standardize structures.

Here are some practices when creating models:

1. **Avoid constructors with parameters**: Prefer to use setters as that ease
on inheritance, testing and avoid compatibility issues in case new parameters
are added to the constructors.
1. **Implement chainable setters**: When a setter is called, it should return
the instance itself, so it can be chained with other setters. That improves
writing code and makes it more readable.
   * Prefer to use `value` as the setter parameter name instead of the 
     property name, example:
     ```lua
     --[[--
     Sets the model name.
     
     @tparam string value the model's name

     @treturn Module.ClassName self
     ]]
     function ClassName:setProperty(value)
         self.property = value
         return self
     end
     ```
1. **There's no need for getters**: Lua doesn't have a way to protect 
properties, so it's not necessary to create getters for them. If a property 
needs to be read, it can be accessed directly, and that will save a lot of
unnecessary code.